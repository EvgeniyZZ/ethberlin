{"ast":null,"code":"/**\n * @license\n * SKALE Filestorage-js\n * Copyright (C) 2019-Present SKALE Labs\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n/**\n * @file index.js\n * @date 2019\n */\nconst Web3 = require('web3');\n\nconst path = require('path');\n\nconst constants = require('./common/constants');\n\nconst Helper = require('./common/helper');\n\nconst FilestorageContract = require('./FilestorageContract');\n\nlet streamSaver = null;\n\nif (typeof window !== 'undefined') {\n  streamSaver = require('streamsaver');\n}\n\nclass FilestorageClient {\n  /**\n   * Initialization of Filestorage API client\n   *\n   * @constructor\n   *\n   * @param {string|object} web3Provider - A URL of SKALE endpoint or one of the Web3 provider classes.\n   * @param {boolean} [enableLogs=false] - Enable/disable console logs.\n   */\n  constructor(web3Provider, enableLogs = false) {\n    this.web3 = new Web3(web3Provider);\n    this.contract = new FilestorageContract(this.web3);\n    this.enableLogs = enableLogs;\n  }\n  /**\n   * Upload file into Filestorage\n   *\n   * @method uploadFile\n   *\n   * @param {string} address - Account address.\n   * @param {string} fileName - Name of uploaded file.\n   * @param {ArrayBuffer} fileBuffer - Data of the file, in bytes.\n   * @param {string} [privateKey] - Account private key.\n   * @returns {string} Storage path.\n   */\n\n\n  async uploadFile(address, fileName, fileBuffer, privateKey) {\n    let fileSize = fileBuffer.length;\n    await this.contract.startUpload(address, fileName, fileSize, privateKey);\n    if (this.enableLogs) console.log('File was created!');\n    let ptrPosition = 0;\n    let i = 0;\n\n    while (ptrPosition < fileSize) {\n      let rawChunk = fileBuffer.slice(ptrPosition, ptrPosition + Math.min(fileSize - ptrPosition, constants.CHUNK_LENGTH));\n      let chunk = Helper.bufferToHex(rawChunk);\n      await this.contract.uploadChunk(address, fileName, ptrPosition, Helper.addBytesSymbol(chunk), privateKey);\n      ptrPosition += chunk.length / 2;\n\n      if (this.enableLogs) {\n        console.log('Chunk ' + i + ' was loaded ' + ptrPosition);\n        ++i;\n      }\n    }\n\n    if (this.enableLogs) console.log('Checking file validity...');\n    await this.contract.finishUpload(address, fileName, privateKey);\n    if (this.enableLogs) console.log('File was uploaded!');\n    return path.join(Helper.rmBytesSymbol(address), fileName);\n  }\n  /**\n   * Download file from Filestorage into browser downloads folder\n   *\n   * @method downloadToFile\n   *\n   * @param {string} storagePath - Path of the file in Filestorage.\n   */\n\n\n  async downloadToFile(storagePath) {\n    if (!streamSaver) {\n      throw new Error('Method downloadToFile can only be used with a browser');\n    }\n\n    const fileName = path.basename(storagePath);\n    let wstream = streamSaver.createWriteStream(fileName).getWriter();\n    await this._downloadFile(storagePath, wstream);\n    wstream.close();\n  }\n  /**\n   * Download file from Filestorage into buffer\n   *\n   * @method downloadToBuffer\n   *\n   * @param {string} storagePath - Path of the file in Filestorage.\n   * @returns {Buffer} - File data in bytes.\n   */\n\n\n  async downloadToBuffer(storagePath) {\n    return await this._downloadFile(storagePath);\n  }\n  /**\n   * Delete file from Filestorage\n   *\n   * @method deleteFile\n   *\n   * @param {string} address - Account address.\n   * @param {string} fileName - Name of the file to be deleted.\n   * @param {string} [privateKey] - Account private key.\n   */\n\n\n  async deleteFile(address, fileName, privateKey) {\n    await this.contract.deleteFile(address, fileName, privateKey);\n    if (this.enableLogs) console.log('File was deleted');\n  }\n  /**\n   * Get information about files in Filestorage of the specific account\n   *\n   * @method getFileInfoListByAddress\n   *\n   * @param {string} address - Account address.\n   * @returns {{name:string, size:number, storagePath:string, uploadingProgress:number}} - File description.\n   */\n\n\n  async getFileInfoListByAddress(address) {\n    let rawFiles = await this.contract.getFileInfoList(address);\n    let files = rawFiles.map(file => {\n      let storagePath = path.join(Helper.rmBytesSymbol(address), file['name']);\n      let chunkStatusList = file['isChunkUploaded'];\n      let uploadedChunksCount = chunkStatusList.filter(x => x === true).length;\n      let uploadingProgress = Math.floor(uploadedChunksCount / chunkStatusList.length * 100);\n      return {\n        name: file['name'],\n        size: parseInt(file['size'], 10),\n        storagePath: storagePath,\n        uploadingProgress: uploadingProgress\n      };\n    });\n    return files;\n  }\n\n  async _downloadFile(storagePath, stream) {\n    let ptrPosition = 0;\n    let i = 0;\n    let buffers = [];\n    const fileSize = await this.contract.getFileSize(storagePath);\n    if (this.enableLogs) console.log('File size: ', fileSize);\n\n    while (ptrPosition < fileSize) {\n      let currentLength = Math.min(constants.CHUNK_LENGTH, fileSize - ptrPosition);\n      let rawData = await this.contract.readChunk(storagePath, ptrPosition, currentLength);\n      let data = Helper.concatBytes32Array(rawData, 2 * currentLength); // eslint-disable-next-line\n\n      let buffer = new Buffer.from(data, 'hex');\n      if (stream) stream.write(buffer);\n      buffers.push(buffer);\n      ptrPosition += currentLength;\n\n      if (this.enableLogs) {\n        console.log('Chunk ' + i + ' was downloaded! Received bytes:' + ptrPosition);\n        ++i;\n      }\n    }\n\n    if (this.enableLogs) console.log('File was downloaded!');\n    return Buffer.concat(buffers);\n  }\n\n}\n\nmodule.exports = FilestorageClient;\nmodule.exports.FilestorageContract = FilestorageContract;","map":null,"metadata":{},"sourceType":"script"}