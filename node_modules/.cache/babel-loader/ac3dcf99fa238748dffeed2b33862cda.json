{"ast":null,"code":"/**\n * @license\n * SKALE Filestorage-js\n * Copyright (C) 2019-Present SKALE Labs\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n/**\n * @file index.js\n * @date 2019\n */\nconst Web3 = require('web3');\n\nconst path = require('path');\n\nconst constants = require('./common/constants');\n\nconst Helper = require('./common/helper');\n\nconst FilestorageContract = require('./FilestorageContract');\n\nlet streamSaver = null;\n\nif (typeof window !== 'undefined') {\n  streamSaver = require('streamsaver');\n}\n\nclass FilestorageClient {\n  /**\n   * Initialization of Filestorage API client\n   *\n   * @class\n   *\n   * @param {string|Object} web3Provider - A URL of SKALE endpoint or one of the Web3 provider classes\n   * @param {boolean} [enableLogs=false] - Enable/disable console logs\n   */\n  constructor(web3Provider, enableLogs = false) {\n    this.web3 = new Web3(web3Provider);\n    this.contract = new FilestorageContract(this.web3);\n    this.enableLogs = enableLogs;\n  }\n  /**\n   * Upload file into Filestorage\n   *\n   * @function uploadFile\n   *\n   * @param {string} address - Account address\n   * @param {string} filePath - Path of uploaded file in account directory\n   * @param {Buffer} fileBuffer - Uploaded file data\n   * @param {string} [privateKey] - Account private key\n   * @returns {string} Storage path\n   */\n\n\n  async uploadFile(address, filePath, fileBuffer, privateKey) {\n    let fileSize = fileBuffer.length;\n    await this.contract.startUpload(address, filePath, fileSize, privateKey);\n    if (this.enableLogs) console.log('File was created!');\n    let ptrPosition = 0;\n    let i = 0;\n\n    while (ptrPosition < fileSize) {\n      let rawChunk = fileBuffer.slice(ptrPosition, ptrPosition + Math.min(fileSize - ptrPosition, constants.CHUNK_LENGTH));\n      let chunk = Helper.bufferToHex(rawChunk);\n      await this.contract.uploadChunk(address, filePath, ptrPosition, Helper.addBytesSymbol(chunk), privateKey);\n      ptrPosition += chunk.length / 2;\n\n      if (this.enableLogs) {\n        console.log('Chunk ' + i + ' was loaded ' + ptrPosition);\n        ++i;\n      }\n    }\n\n    if (this.enableLogs) console.log('Checking file validity...');\n    await this.contract.finishUpload(address, filePath, privateKey);\n    if (this.enableLogs) console.log('File was uploaded!');\n    return path.posix.join(Helper.rmBytesSymbol(address), filePath);\n  }\n  /**\n   * Download file from Filestorage into browser downloads folder\n   *\n   * @function downloadToFile\n   *\n   * @param {string} storagePath - Path of the file in Filestorage\n   */\n\n\n  async downloadToFile(storagePath) {\n    if (!streamSaver) {\n      throw new Error('Method downloadToFile can only be used with a browser');\n    }\n\n    const fileName = path.posix.basename(storagePath);\n    let wstream = streamSaver.createWriteStream(fileName).getWriter();\n    await this._downloadFile(storagePath, wstream);\n    wstream.close();\n  }\n  /**\n   * Download file from Filestorage into buffer\n   *\n   * @function downloadToBuffer\n   *\n   * @param {string} storagePath - Path of the file in Filestorage\n   * @returns {Buffer} - File data in bytes\n   */\n\n\n  async downloadToBuffer(storagePath) {\n    return await this._downloadFile(storagePath);\n  }\n  /**\n   * Delete file from Filestorage\n   *\n   * @function deleteFile\n   *\n   * @param {string} address - Account address\n   * @param {string} filePath - Path to the file to be deleted\n   * @param {string} [privateKey] - Account private key\n   */\n\n\n  async deleteFile(address, filePath, privateKey) {\n    await this.contract.deleteFile(address, filePath, privateKey);\n    if (this.enableLogs) console.log('File was deleted');\n  }\n  /**\n   * Create directory in Filestorage\n   *\n   * @function createDirectory\n   *\n   * @param {string} address - Account address\n   * @param {string} directoryPath - Path of the directory to be created\n   * @param {string} [privateKey] - Account private key\n   * @returns {string} Storage path\n   */\n\n\n  async createDirectory(address, directoryPath, privateKey) {\n    await this.contract.createDirectory(address, directoryPath, privateKey);\n    if (this.enableLogs) console.log('Directory was created');\n    return path.posix.join(Helper.rmBytesSymbol(address), directoryPath);\n  }\n  /**\n   * Delete directory from Filestorage\n   *\n   * @function deleteDirectory\n   *\n   * @param {string} address - Account address\n   * @param {string} directoryPath - Path of the directory to be deleted\n   * @param {string} [privateKey] - Account private key\n   */\n\n\n  async deleteDirectory(address, directoryPath, privateKey) {\n    await this.contract.deleteDirectory(address, directoryPath, privateKey);\n    if (this.enableLogs) console.log('Directory was deleted');\n  }\n  /**\n   * List information about content of the directory\n   *\n   * @function listDirectory\n   *\n   * @param {string} storagePath - Path of the directory in Filestorage\n   * @returns {Array.<{name:string, storagePath:string, isFile:boolean, size:number, status:number,\n   * uploadingProgress:number}|{name:string, storagePath:string, isFile:boolean}>} - List of content:\n   * files or directories\n   */\n\n\n  async listDirectory(storagePath) {\n    if (storagePath.slice(-1) !== '/') storagePath += '/';\n    let rawContent = await this.contract.listDirectory(storagePath);\n    let content = rawContent.map(contentInfo => {\n      let contentStoragePath = path.posix.join(storagePath, contentInfo['name']);\n      let contentInfoObject = {\n        name: contentInfo['name'],\n        storagePath: contentStoragePath,\n        isFile: contentInfo['isFile']\n      };\n\n      if (!contentInfoObject.isFile) {\n        return contentInfoObject;\n      }\n\n      let chunkStatusList = contentInfo['isChunkUploaded'];\n      let uploadedChunksCount = chunkStatusList.filter(x => x === true).length;\n      let uploadingProgress = chunkStatusList.length === 0 ? 100 : Math.floor(uploadedChunksCount / chunkStatusList.length * 100);\n      let fileInfoObject = {\n        size: Number(contentInfo['size']),\n        status: Number(contentInfo['status']),\n        uploadingProgress: uploadingProgress\n      };\n      return Object.assign(contentInfoObject, fileInfoObject);\n    });\n    return content;\n  }\n\n  async _downloadFile(storagePath, stream) {\n    let ptrPosition = 0;\n    let i = 0;\n    let buffers = [];\n    const fileSize = await this.contract.getFileSize(storagePath);\n    if (this.enableLogs) console.log('File size: ', fileSize);\n\n    while (ptrPosition < fileSize) {\n      let currentLength = Math.min(constants.CHUNK_LENGTH, fileSize - ptrPosition);\n      let rawData = await this.contract.readChunk(storagePath, ptrPosition, currentLength);\n      let data = Helper.concatBytes32Array(rawData, 2 * currentLength); // eslint-disable-next-line\n\n      let buffer = new Buffer.from(data, 'hex');\n      if (stream) stream.write(buffer);\n      buffers.push(buffer);\n      ptrPosition += currentLength;\n\n      if (this.enableLogs) {\n        console.log('Chunk ' + i + ' was downloaded! Received bytes:' + ptrPosition);\n        ++i;\n      }\n    }\n\n    if (this.enableLogs) console.log('File was downloaded!');\n    return Buffer.concat(buffers);\n  }\n\n}\n\nmodule.exports = FilestorageClient;\nmodule.exports.FilestorageContract = FilestorageContract;","map":null,"metadata":{},"sourceType":"script"}