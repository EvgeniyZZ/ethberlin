{"ast":null,"code":"/* global location WritableStream ReadableStream define MouseEvent MessageChannel TransformStream */\n;\n\n((name, definition) => {\n  typeof module !== 'undefined' ? module.exports = definition() : typeof define === 'function' && typeof define.amd === 'object' ? define(definition) : this[name] = definition();\n})('streamSaver', () => {\n  'use strict';\n\n  const secure = location.protocol === 'https:' || location.protocol === 'chrome-extension:' || location.hostname === 'localhost';\n  let iframe;\n  let loaded;\n  let transfarableSupport = false;\n  let streamSaver = {\n    createWriteStream,\n    supported: false,\n    version: {\n      full: '1.2.0',\n      major: 1,\n      minor: 2,\n      dot: 0\n    }\n  };\n  streamSaver.mitm = 'https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=' + streamSaver.version.full;\n\n  try {\n    // Some browser has it but ain't allowed to construct a stream yet\n    streamSaver.supported = 'serviceWorker' in navigator && !!new ReadableStream() && !!new WritableStream();\n  } catch (err) {}\n\n  try {\n    const _ref = new TransformStream(),\n          readable = _ref.readable;\n\n    const mc = new MessageChannel();\n    mc.port1.postMessage(readable, [readable]);\n    mc.port1.close();\n    mc.port2.close();\n    transfarableSupport = readable.locked === true;\n  } catch (err) {// Was first enabled in chrome v73\n  }\n\n  function createWriteStream(filename, queuingStrategy, size) {\n    // normalize arguments\n    if (Number.isFinite(queuingStrategy)) {\n      var _ref2 = [queuingStrategy, size];\n      size = _ref2[0];\n      queuingStrategy = _ref2[1];\n    }\n\n    let channel = new MessageChannel();\n    let popup;\n\n    let setupChannel = readableStream => new Promise(resolve => {\n      const args = [{\n        filename,\n        size\n      }, '*', [channel.port2]]; // Pass along transfarable stream\n\n      if (readableStream) {\n        args[0].readableStream = readableStream;\n        args[2].push(readableStream);\n      }\n\n      channel.port1.onmessage = evt => {\n        // Service worker sent us a link from where\n        // we recive the readable link (stream)\n        if (evt.data.download) {\n          resolve(); // Signal that the writestream are ready to recive data\n\n          if (!secure) popup.close(); // don't need the popup any longer\n\n          if (window.chrome && chrome.extension && chrome.extension.getBackgroundPage && chrome.extension.getBackgroundPage() === window) {\n            chrome.tabs.create({\n              url: evt.data.download,\n              active: false\n            });\n          } else {\n            window.location = evt.data.download;\n          } // Cleanup\n\n\n          if (readableStream) {\n            // We don't need postMessages now when stream are transferable\n            channel.port1.close();\n            channel.port2.close();\n          }\n\n          channel.port1.onmessage = null;\n        }\n      };\n\n      if (secure && !iframe) {\n        iframe = document.createElement('iframe');\n        iframe.src = streamSaver.mitm;\n        iframe.hidden = true;\n        document.body.appendChild(iframe);\n      }\n\n      if (secure && !loaded) {\n        let fn;\n        iframe.addEventListener('load', fn = () => {\n          loaded = true;\n          iframe.removeEventListener('load', fn);\n          iframe.contentWindow.postMessage(...args);\n        });\n      }\n\n      if (secure && loaded) {\n        iframe.contentWindow.postMessage(...args);\n      }\n\n      if (!secure) {\n        popup = window.open(streamSaver.mitm, Math.random());\n\n        let onready = evt => {\n          if (evt.source === popup) {\n            popup.postMessage(...args);\n            window.removeEventListener('message', onready);\n          }\n        }; // Another problem that cross origin don't allow is scripting\n        // so popup.onload() don't work but postMessage still dose\n        // work cross origin\n\n\n        window.addEventListener('message', onready);\n      }\n    });\n\n    if (transfarableSupport) {\n      const ts = new TransformStream({\n        start() {\n          return new Promise(resolve => setTimeout(() => setupChannel(ts.readable).then(resolve)));\n        }\n\n      }, queuingStrategy);\n      return ts.writable;\n    }\n\n    return new WritableStream({\n      start() {\n        // is called immediately, and should perform any actions\n        // necessary to acquire access to the underlying sink.\n        // If this process is asynchronous, it can return a promise\n        // to signal success or failure.\n        return setupChannel();\n      },\n\n      write(chunk) {\n        // is called when a new chunk of data is ready to be written\n        // to the underlying sink. It can return a promise to signal\n        // success or failure of the write operation. The stream\n        // implementation guarantees that this method will be called\n        // only after previous writes have succeeded, and never after\n        // close or abort is called.\n        // TODO: Kind of important that service worker respond back when\n        // it has been written. Otherwise we can't handle backpressure\n        // EDIT: Transfarable streams solvs this...\n        channel.port1.postMessage(chunk);\n      },\n\n      close() {\n        channel.port1.postMessage('end');\n      },\n\n      abort() {\n        channel.port1.postMessage('abort');\n      }\n\n    }, queuingStrategy);\n  }\n\n  return streamSaver;\n});","map":null,"metadata":{},"sourceType":"script"}